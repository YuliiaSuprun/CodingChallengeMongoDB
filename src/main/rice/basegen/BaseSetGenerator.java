package main.rice.basegen;

import main.rice.node.APyNode;
import main.rice.obj.APyObj;
import main.rice.test.TestCase;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

/**
 * A concrete class representing a base set generator, which produces the base set of
 * test cases that are used for testing buggy implementations of the function under test.
 */
public class BaseSetGenerator {

    /**
     * A list of nodes encapsulating the type and domain specifications for each
     * parameter to the function under test.
     */
    private final List<APyNode<?>> nodes;
    /**
     * An integer representing the number of random tests cases to generate.
     */
    private final int numRand;

    /**
     * Constructor for a BaseSetGenerator; initializes its list of nodes and
     * the number of random tests cases to the input values.
     *
     * @param nodes   a list of nodes encapsulating the type and domain specifications for
     *                each parameter to the function under test.
     * @param numRand an integer representing the number of random tests cases to generate
     */
    public BaseSetGenerator(List<APyNode<?>> nodes, int numRand) {
        this.nodes = nodes;
        this.numRand = numRand;
    }

    /**
     * Generates the base test set, which should be the union of all tests within the
     * exhaustive domain and a selection of tests within the random domain. Each output
     * test case encapsulates a list of arguments (APyObjs), where the i-th argument is
     * typified by the i-th element in the list of nodes that was passed at construction.
     *
     * @return a list of TestCases representing all test cases from the exhaustive domain
     * and a specified number of test cases from the random domain.
     */
    public List<TestCase> genBaseSet() {
        // Call a helper function, which adds a specified number of random tests to the
        // set of exhaustive tests such that no two test cases overlap.
        return new ArrayList<>(this.addRandTests(this.genExTests()));
    }

    /**
     * Generates and returns the set of all test cases adhering to the type and exhaustive
     * domain specifications in the list of nodes that was passed during construction.
     *
     * @return a set of TestCases representing all test cases from the exhaustive domain.
     */
    public Set<TestCase> genExTests() {
        // Call a recursive helper function that generates all the exhaustive tests
        return this.helperGenExTests(this.nodes.size() - 1);
    }

    /**
     * A helper function that generates and returns the exhaustive set of all test cases
     * for the first (index + 1) nodes in the list of nodes.
     *
     * @param index an integer representing the index of the last element in the list of
     *              nodes, for which an exhaustive set of test cases is generated
     * @return a set of TestCases representing all test cases from the exhaustive domain
     * for the first (index + 1) nodes in the list of nodes.
     */
    private Set<TestCase> helperGenExTests(int index) {
        // Initialize the empty sets of old and new test cases
        Set<TestCase> oldTests = new HashSet<>();
        Set<TestCase> newTests = new HashSet<>();
        // Base Case
        if (index == 0) {
            // Add a trivial test case, a wrapper around an empty list of arguments
            oldTests.add(new TestCase(new ArrayList<>()));
        } else {
            // Recursive case: generate an exhaustive set of cases for first (index) nodes
            oldTests = helperGenExTests(index - 1);
        }
        // Iterate over all possible values generated by the node at the position (index)
        for (APyObj genObj : this.nodes.get(index).genExVals()) {
            // Iterate over all old test cases
            for (TestCase oldTest : oldTests) {
                // Create a copy of each old test case
                List<APyObj> newArgs = new ArrayList<>(oldTest.getArgs());
                // Add each generated value to each old test case in the position (index)
                newArgs.add(genObj);
                // Add a new test case to a set of new test cases
                newTests.add(new TestCase(newArgs));
            }
        }
        return newTests;
    }

    /**
     * Generates and returns a random selection of test cases adhering to the type and
     * random domain specifications in the input list of nodes. The size of the returned
     * set should be equal to the numRand value passed during construction.
     *
     * @return a list of TestCases representing a specified number of unique test cases
     * the random domain.
     */
    public Set<TestCase> genRandTests() {
        // Call a helper function, which adds a specified number of random tests to the
        // empty set such that no two test cases overlap.
        return this.addRandTests(new HashSet<>());
    }

    /**
     * A helper function that takes as its input some set of test cases and adds a
     * specified number of test cases from the random domain such that no two test cases
     * overlap.
     *
     * @return a set of TestCases, which is a union of the input set of test cases and
     * a set of a specified number of test cases from the random domain.
     */
    private Set<TestCase> addRandTests(Set<TestCase> exTests) {
        // Initialize a counter
        int count = 0;
        while (count < this.numRand) {
            // Create an empty list for the arguments of a new random test case
            List<APyObj> args = new ArrayList<>();
            // Randomly choose the argument for each node, creating a random list of
            // arguments for some test case
            for (APyNode<?> node : this.nodes) {
                args.add(node.genRandVal());
            }
            // Create a new test case with these random arguments
            TestCase newTest = new TestCase(args);
            // If a set of existing test cases doesn't contain this new random test case:
            if (!exTests.contains(newTest)) {
                // Add this test case to a set
                exTests.add(newTest);
                // Increment a counter, representing a total number of random tests added
                count++;
            }
        }
        return exTests;
    }

}
